<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced 2D Motion: The Net Problem</title>
    <style>
        :root {
            --bg-color: #111827; --card-bg: #1f2937; --primary-text: #f9fafb; --secondary-text: #9ca3af;
            --accent-purple: #8b5cf6; --accent-blue: #38bdf8; --success-green: #4ade80; --failure-red: #f87171;
            --border-color: #374151; --shadow-color: rgba(0, 0, 0, 0.25);
        }
        body { font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; background-color: var(--bg-color); padding: 20px; color: var(--primary-text); box-sizing: border-box; }
        .header { width: 100%; max-width: 1200px; display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 20px; }
        #logo { width: 75px; height: 75px; border-radius: 12px; flex-shrink: 0; object-fit: contain; background-color: var(--card-bg); }
        h1 { font-size: 2.5em; font-weight: 700; color: var(--primary-text); margin: 0; }
        .main-container, #explanation-area { width: 100%; max-width: 1200px; background: var(--card-bg); padding: 25px; border-radius: 16px; box-shadow: 0 8px 24px var(--shadow-color); border: 1px solid var(--border-color); }
        .main-container { display: flex; flex-wrap: wrap; gap: 30px; }
        #controls { flex: 1; min-width: 300px; }
        #simulation-area { flex: 2; min-width: 400px; }
        h2, h3, h4 { margin-top: 0; font-weight: 600; }
        h2 { font-size: 1.5em; color: var(--accent-purple); border-bottom: 2px solid var(--border-color); padding-bottom: 10px; }
        h3 { font-size: 1.3em; margin-top: 25px; color: var(--accent-blue); border-bottom: 1px solid var(--border-color); padding-bottom: 8px; }
        h4 { font-size: 1.2em; color: var(--accent-blue); border-bottom: 1px solid var(--border-color); padding-bottom: 8px; }
        .slider-group { margin-bottom: 20px; }
        .slider-group label { font-size: 1em; color: var(--secondary-text); font-weight: 500; display: block; margin-bottom: 10px; }
        .value-display { font-weight: bold; color: var(--accent-purple); }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 8px; background: var(--border-color); border-radius: 5px; outline: none; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: var(--accent-blue); border-radius: 50%; border: 2px solid var(--card-bg); box-shadow: 0 0 8px rgba(56, 189, 248, 0.5); transition: transform 0.1s ease, box-shadow 0.1s ease; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.1); box-shadow: 0 0 12px rgba(56, 189, 248, 0.7); }
        .button-group { display: flex; gap: 10px; margin-top: 25px; }
        #runButton, #resetButton { flex-grow: 1; padding: 15px; font-size: 1.1em; font-weight: bold; color: white; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        #runButton { background-image: linear-gradient(to right, var(--accent-purple), var(--accent-blue)); }
        #resetButton { background-image: linear-gradient(to right, #4b5563, #374151); }
        #runButton:hover, #resetButton:hover { transform: translateY(-2px); box-shadow: 0 6px 15px rgba(0,0,0,0.3); }
        #canvas { width: 100%; height: auto; aspect-ratio: 16 / 9; border: 1px solid var(--border-color); background-color: #0c111c; border-radius: 8px; }
        #results { margin-top: 20px; padding: 15px; background-color: #111827; border-radius: 8px; border: 1px solid var(--border-color); font-size: 1.1em; text-align: center; }
        .success { color: var(--success-green); font-weight: bold; }
        .failure { color: var(--failure-red); font-weight: bold; }
        #explanation-area { margin-top: 30px; }
        .equation { background: #111827; padding: 12px; border-radius: 5px; margin: 10px 0; font-size: 1.1em; overflow-x: auto; line-height: 1.8; border: 1px solid var(--border-color); }
        .calculation-grid { display: flex; flex-wrap: wrap; gap: 25px; margin-top: 20px; }
        .calc-column { flex: 1; min-width: 300px; padding: 20px; border: 1px solid var(--border-color); border-radius: 8px; background: #111827; }
        .suvat-list { list-style: none; padding: 0; }
        .suvat-list li { margin-bottom: 5px; color: var(--secondary-text); }
        sub, sup { font-size: 0.8em; position: relative; line-height: 0; vertical-align: baseline; }
        sub { top: 0.5em; }
        sup { top: -0.5em; }
    </style>
</head>
<body>
    <header class="header">
        <img id="logo" src="lr-1.png" alt="Logo">
        <h1>Advanced 2D Motion: The Net Problem</h1>
    </header>

    <div class="main-container">
        <div id="controls">
            <h2>Parameters</h2>
            <div class="slider-group"><label>Initial Height (Pillar): <span id="height-value" class="value-display"></span> m</label><input type="range" id="height" min="1" max="10" value="2.8" step="0.1"></div>
            <div class="slider-group"><label>Initial Speed: <span id="speed-value" class="value-display"></span> m/s</label><input type="range" id="speed" min="5" max="75" value="64" step="0.5"></div>
            <div class="slider-group"><label>Angle Below Horizontal: <span id="angle-value" class="value-display"></span>Â°</label><input type="range" id="angle" min="0" max="45" value="7" step="1"></div>
            <div class="slider-group"><label>Distance to Net: <span id="netDist-value" class="value-display"></span> m</label><input type="range" id="netDist" min="1" max="50" value="11.9" step="0.1"></div>
            <div class="slider-group"><label>Net Height: <span id="netHeight-value" class="value-display"></span> m</label><input type="range" id="netHeight" min="0.5" max="5" value="0.91" step="0.01"></div>
            <hr style="border: none; border-top: 1px solid var(--border-color); margin: 20px 0;">
            <div class="slider-group"><label>Bounciness (Restitution): <span id="restitution-value" class="value-display"></span></label><input type="range" id="restitution" min="0.1" max="0.9" value="0.7" step="0.05"></div>
            <div class="slider-group"><label>Simulation Speed: <span id="simSpeed-value" class="value-display"></span>x</label><input type="range" id="simSpeed" min="0.1" max="4" value="1" step="0.1"></div>
            <div class="button-group"><button id="runButton">Run Simulation</button><button id="resetButton">Reset</button></div>
        </div>
        <div id="simulation-area">
            <canvas id="canvas"></canvas>
            <div id="results">Set parameters and press "Run Simulation"</div>
        </div>
    </div>

    <div id="explanation-area">
        <h2>Solution by Two-Model Approach (SUVAT)</h2>
        <div id="solution-content"><p>Press "Run Simulation" to see the detailed calculations for the initial trajectory.</p></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const g = 9.81;
            const BALL_RADIUS_PX = 6;
            let animationFrameId;
            let simState = 'idle';
            let ball = {};
            let trajectoryPoints = [];

            const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
            const resultsEl = document.getElementById('results'), solutionContentEl = document.getElementById('solution-content');
            const runButton = document.getElementById('runButton'), resetButton = document.getElementById('resetButton');

            const sliders = {
                height: document.getElementById('height'), speed: document.getElementById('speed'), angle: document.getElementById('angle'),
                netDist: document.getElementById('netDist'), netHeight: document.getElementById('netHeight'),
                restitution: document.getElementById('restitution'), simSpeed: document.getElementById('simSpeed')
            };
            const defaultValues = { height: 2.8, speed: 64, angle: 7, netDist: 11.9, netHeight: 0.91, restitution: 0.7, simSpeed: 1 };
            const values = {
                height: document.getElementById('height-value'), speed: document.getElementById('speed-value'), angle: document.getElementById('angle-value'),
                netDist: document.getElementById('netDist-value'), netHeight: document.getElementById('netHeight-value'),
                restitution: document.getElementById('restitution-value'), simSpeed: document.getElementById('simSpeed-value')
            };

            function updateSliderDisplays() {
                values.height.textContent = parseFloat(sliders.height.value).toFixed(2);
                values.speed.textContent = parseFloat(sliders.speed.value).toFixed(1);
                values.angle.textContent = parseFloat(sliders.angle.value).toFixed(0);
                values.netDist.textContent = parseFloat(sliders.netDist.value).toFixed(1);
                values.netHeight.textContent = parseFloat(sliders.netHeight.value).toFixed(2);
                values.restitution.textContent = parseFloat(sliders.restitution.value).toFixed(2);
                values.simSpeed.textContent = parseFloat(sliders.simSpeed.value).toFixed(2);
            }

            function resetSimulation() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                simState = 'idle';
                for (const key in sliders) sliders[key].value = defaultValues[key];
                updateSliderDisplays();
                resultsEl.innerHTML = 'Set parameters and press "Run Simulation"';
                solutionContentEl.innerHTML = '<p>Press "Run Simulation" to see the detailed calculations.</p>';
                drawInitialSetup();
                runButton.disabled = false;
            }

            function runSimulation() {
                if (simState === 'running') return;
                simState = 'running';
                runButton.disabled = true;

                const params = calculateInitialPhysics();
                updateResultsAndExplanation(params);

                const { scale } = getCanvasConfig(params);
                const ball_radius_m = BALL_RADIUS_PX / scale;

                ball = {
                    x: 0,
                    y: params.h + ball_radius_m,
                    vx: params.u_x,
                    vy: params.u_y,
                    radius_m: ball_radius_m
                };
                trajectoryPoints = [{x: ball.x, y: ball.y}];

                let lastTimestamp = 0;
                function animate(timestamp) {
                    if (!lastTimestamp) lastTimestamp = timestamp;
                    const deltaTime = ((timestamp - lastTimestamp) / 1000) * parseFloat(sliders.simSpeed.value);
                    lastTimestamp = timestamp;

                    if (simState !== 'running') return;
                    
                    updateBallState(deltaTime);
                    drawAnimatedFrame(params);

                    // Stop if ball is barely moving on the ground
                    if (Math.abs(ball.vy) < 0.1 && ball.y === ball.radius_m) {
                        const staticEnergy = g * ball.radius_m;
                        if (0.5 * ball.vy * ball.vy < staticEnergy){
                             // Animation can be stopped here, but we let it run
                        }
                    }

                    animationFrameId = requestAnimationFrame(animate);
                }
                animationFrameId = requestAnimationFrame(animate);
            }

            function updateBallState(dt) {
                // Update velocity due to gravity
                ball.vy -= g * dt;

                // Update position
                ball.x += ball.vx * dt;
                ball.y += ball.vy * dt;

                trajectoryPoints.push({x: ball.x, y: ball.y});

                // Collision with ground
                if (ball.y < ball.radius_m) {
                    ball.y = ball.radius_m;
                    ball.vy *= -parseFloat(sliders.restitution.value);
                    ball.vx *= 0.95; // Ground friction
                }
            }

            function calculateInitialPhysics() {
                const h = parseFloat(sliders.height.value), u = parseFloat(sliders.speed.value), angleDeg = parseFloat(sliders.angle.value),
                      d_net = parseFloat(sliders.netDist.value), h_net = parseFloat(sliders.netHeight.value);
                const angleRad = -angleDeg * Math.PI / 180;
                const u_x = u * Math.cos(angleRad), u_y = u * Math.sin(angleRad);

                const temp_params = { h, d_net, x_land: u_x * ( (u_y + Math.sqrt(u_y*u_y + 2*g*h)) / g ) };
                const { scale } = getCanvasConfig(temp_params);
                const ball_radius_m = BALL_RADIUS_PX / scale;
                const h_effective = h + ball_radius_m;
                
                const t_net = d_net / u_x;
                const y_center_at_net = h_effective + u_y * t_net - 0.5 * g * t_net * t_net;
                const clearance = (y_center_at_net - ball_radius_m) - h_net;
                
                const a_q = -0.5 * g, b_q = u_y, c_q = h_effective;
                const t_ground = (-b_q - Math.sqrt(b_q * b_q - 4 * a_q * c_q)) / (2 * a_q);
                const x_land = u_x * t_ground;
                
                const v_y_final = u_y - g * t_ground;
                const v_impact_mag = Math.sqrt(u_x * u_x + v_y_final * v_y_final);
                const v_impact_angle = Math.atan2(v_y_final, u_x) * 180 / Math.PI;

                return {
                    clearance, y_center_at_net, x_land, d_net, v_impact_mag, v_impact_angle, h, u, angleDeg, h_net, u_x, u_y, t_net,
                    h_effective, t_ground, v_y_final, ball_radius_m
                };
            }

            function getCanvasConfig(params) {
                const rect = canvas.parentElement.getBoundingClientRect();
                const canvasWidth = rect.width;
                const canvasHeight = rect.width * (9 / 16);
                
                const worldWidth = Math.max(params.d_net * 1.5, params.x_land * 1.2, 30);
                const worldHeight = Math.max(params.h * 1.5, 10);
                const scale = Math.min(canvasWidth / worldWidth, canvasHeight / worldHeight);
                const padding = 50;
                const transform = (wx, wy) => ({ x: padding + wx * scale, y: canvasHeight - padding - wy * scale });

                return { canvasWidth, canvasHeight, scale, padding, transform };
            }

            function drawStaticScene(config, params) {
                const { canvasWidth, canvasHeight, transform } = config;
                canvas.width = canvasWidth; canvas.height = canvasHeight;
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                ctx.fillStyle = "#0c111c";
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                const { h, d_net, h_net } = params;
                
                ctx.beginPath(); ctx.moveTo(transform(0, 0).x - 50, transform(0, 0).y); ctx.lineTo(canvasWidth, transform(0, 0).y);
                ctx.strokeStyle = '#664229'; ctx.lineWidth = 4; ctx.stroke();
                
                const netBottom = transform(d_net, 0), netTop = transform(d_net, h_net);
                ctx.beginPath(); ctx.moveTo(netBottom.x, netBottom.y); ctx.lineTo(netTop.x, netTop.y);
                ctx.strokeStyle = '#f9fafb'; ctx.lineWidth = 4; ctx.stroke();
                
                const pillarWidth = 12;
                const pillarTop = transform(0, h);
                const groundY = transform(0, 0).y;
                ctx.fillStyle = '#5D6D7E';
                ctx.fillRect(pillarTop.x - pillarWidth / 2, pillarTop.y, pillarWidth, groundY - pillarTop.y);
            }
            
            function drawInitialSetup() {
                const params = calculateInitialPhysics();
                const config = getCanvasConfig(params);
                drawStaticScene(config, params);
                
                const { transform } = config;
                const { h_effective, angleDeg } = params;
                const angleRad = -angleDeg * Math.PI / 180;
                
                const startPos = transform(0, h_effective);
                ctx.beginPath(); ctx.arc(startPos.x, startPos.y, BALL_RADIUS_PX, 0, 2*Math.PI);
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-blue').trim(); ctx.fill();
            }

            function drawAnimatedFrame(params) {
                const config = getCanvasConfig(params);
                drawStaticScene(config, params);

                const { transform, scale } = config;
                
                // Draw trajectory trail
                ctx.beginPath();
                const startPoint = transform(trajectoryPoints[0].x, trajectoryPoints[0].y);
                ctx.moveTo(startPoint.x, startPoint.y);
                ctx.strokeStyle = 'rgba(56, 189, 248, 0.5)';
                ctx.lineWidth = 2;
                for (let i = 1; i < trajectoryPoints.length; i++) {
                    const point = transform(trajectoryPoints[i].x, trajectoryPoints[i].y);
                    ctx.lineTo(point.x, point.y);
                }
                ctx.stroke();

                // Draw ball
                const ball_pos = transform(ball.x, ball.y);
                ctx.beginPath();
                ctx.arc(ball_pos.x, ball_pos.y, BALL_RADIUS_PX, 0, 2 * Math.PI);
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--failure-red').trim();
                ctx.fill();

                // Draw velocity vectors
                const vector_scale = scale * 0.05;
                const vxColor = '#4ade80', vyColor = '#f87171';

                // Vx vector
                drawArrow(ctx, ball_pos.x, ball_pos.y, ball_pos.x + ball.vx * vector_scale, ball_pos.y, vxColor, 2);
                // Vy vector
                drawArrow(ctx, ball_pos.x, ball_pos.y, ball_pos.x, ball_pos.y - ball.vy * vector_scale, vyColor, 2);
            }

            function drawArrow(ctx, fromx, fromy, tox, toy, color, width) {
                const headlen = 8;
                const dx = tox - fromx, dy = toy - fromy;
                const angle = Math.atan2(dy, dx);
                ctx.beginPath(); ctx.moveTo(fromx, fromy); ctx.lineTo(tox, toy);
                ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(tox, toy); ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
                ctx.strokeStyle = color; ctx.lineWidth = width; ctx.stroke();
            }

            function updateResultsAndExplanation(p) {
                // This function now only calculates for the initial arc, the simulation handles the rest
                resultsEl.innerHTML = (p.x_land < p.d_net) ? `<span class="failure">FAILS TO REACH NET</span><br>Initial arc lands at ${p.x_land.toFixed(2)}m.` :
                                      (p.clearance > 0) ? `<span class="success">CLEARS THE NET</span> by ${p.clearance.toFixed(2)}m.` :
                                      `<span class="failure">HITS THE NET</span> (Missed by ${Math.abs(p.clearance).toFixed(2)}m).`;
                resultsEl.innerHTML += `<br>First Impact Speed: ${p.v_impact_mag.toFixed(2)} m/s at ${p.v_impact_angle.toFixed(1)}Â°`;

                const successClass = p.clearance > 0 ? 'success' : 'failure';
                const conclusionText = p.x_land < p.d_net ? `The ball lands at ${p.x_land.toFixed(2)}m, short of the net.` :
                                       p.clearance > 0 ? `The ball's bottom edge is <span class="${successClass}">${p.clearance.toFixed(2)}m</span> above the net. It clears.` :
                                       `The ball's bottom edge is <span class="${successClass}">${Math.abs(p.clearance).toFixed(2)}m</span> below the net. It hits.`;

                solutionContentEl.innerHTML = `
                    <p>The initial velocity (u = ${p.u.toFixed(1)} m/s at ${p.angleDeg}Â°) is resolved into components:</p>
                    <div class="equation" style="text-align:center;">
                        u<sub>x</sub> = u &middot; cos(Î¸) = <strong>${p.u_x.toFixed(2)} m/s</strong> &nbsp;&nbsp;|&nbsp;&nbsp; u<sub>y</sub> = u &middot; sin(Î¸) = <strong>${p.u_y.toFixed(2)} m/s</strong>
                    </div>
                    <div class="calculation-grid">
                        <div class="calc-column">
                            <h4>Horizontal Motion</h4>
                            <p><b>Find: Time to reach net (s = ${p.d_net}m)</b><br>Using s = ut</p>
                            <div class="equation">t<sub>net</sub> = ${p.d_net} / ${p.u_x.toFixed(2)} = <strong>${p.t_net.toFixed(2)} s</strong></div>
                        </div>
                        <div class="calc-column">
                            <h4>Vertical Motion</h4>
                            <p><b>Find: Height at net (at t = ${p.t_net.toFixed(2)}s)</b><br>Using s = ut + &frac12;atÂ²</p>
                            <div class="equation">y<sub>net</sub> = ${p.h_effective.toFixed(2)} + (${p.u_y.toFixed(2)})(${p.t_net.toFixed(2)}) + &frac12;(-${g})(${p.t_net.toFixed(2)})&sup2; = <strong>${p.y_center_at_net.toFixed(2)} m</strong></div>
                        </div>
                    </div>
                    <h3>Conclusion: Net Clearance (Initial Arc)</h3>
                    <p>The ball's center is at ${p.y_center_at_net.toFixed(2)}m vertically when it reaches the net. Its radius is ${p.ball_radius_m.toFixed(2)}m.</p>
                    <div class="equation">Clearance = (y<sub>net</sub> - r) - h<sub>net</sub> = (${p.y_center_at_net.toFixed(2)} - ${p.ball_radius_m.toFixed(2)}) - ${p.h_net} = <strong class="${successClass}">${p.clearance.toFixed(2)} m</strong></div>
                    <p><b>${conclusionText}</b> The simulation will continue with bounces after this first arc.</p>`;
            }

            for (const key in sliders) {
                sliders[key].addEventListener('input', () => {
                    updateSliderDisplays();
                    if (simState !== 'running') drawInitialSetup();
                });
            }
            runButton.addEventListener('click', runSimulation);
            resetButton.addEventListener('click', resetSimulation);
            
            resetSimulation();
        });
    </script>
</body>
</html>
