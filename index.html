<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Motion: The Net Problem</title>
    <style>
        :root {
            --bg-color: #38C2C9;
            --card-bg: #ffffff;
            --primary-text: #1e293b;
            --secondary-text: #475569;
            --accent-purple: #6d28d9;
            --accent-blue: #2563eb;
            --success-green: #16a34a;
            --failure-red: #dc2626;
            --border-color: #e2e8f0;
            --shadow-color: rgba(149, 157, 165, 0.15);
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--bg-color);
            padding: 20px;
            color: var(--primary-text);
            box-sizing: border-box;
        }

        .header {
            width: 100%;
            max-width: 1200px;
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }

        #logo {
            width: 75px;
            height: 75px;
            border-radius: 12px;
            flex-shrink: 0;
            object-fit: contain; /* Ensures your logo fits nicely */
        }

        h1 {
            font-size: 2.5em;
            font-weight: 700;
            color: var(--primary-text);
            margin: 0;
        }

        .main-container, #explanation-area {
            width: 100%;
            max-width: 1200px;
            background: var(--card-bg);
            padding: 25px;
            border-radius: 16px;
            box-shadow: 0 8px 24px var(--shadow-color);
        }

        .main-container { display: flex; flex-wrap: wrap; gap: 30px; }
        #controls { flex: 1; min-width: 300px; }
        #simulation-area { flex: 2; min-width: 400px; }
        
        h2, h3, h4 { margin-top: 0; font-weight: 600; }
        h2 { font-size: 1.5em; color: var(--accent-purple); border-bottom: 2px solid var(--border-color); padding-bottom: 10px; }
        h3 { font-size: 1.3em; margin-top: 25px; color: var(--accent-blue); border-bottom: 1px solid var(--border-color); padding-bottom: 8px; }
        h4 { font-size: 1.2em; color: var(--accent-blue); border-bottom: 1px solid var(--border-color); padding-bottom: 8px; }

        .slider-group { margin-bottom: 20px; }
        .slider-group label { font-size: 1em; color: var(--secondary-text); font-weight: 500; display: block; margin-bottom: 10px; }
        .value-display { font-weight: bold; color: var(--accent-purple); }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #dbeafe;
            border-radius: 5px;
            outline: none;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-blue);
            border-radius: 50%;
            border: 2px solid var(--card-bg);
            box-shadow: 0 0 5px rgba(0,0,0,0.2);
            transition: transform 0.1s ease;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .button-group { display: flex; gap: 10px; margin-top: 25px; }
        #runButton, #resetButton {
            flex-grow: 1; padding: 15px; font-size: 1.1em; font-weight: bold; color: white; border: none;
            border-radius: 8px; cursor: pointer; transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        #runButton { background-image: linear-gradient(to right, #090979, #00D4FF); }
        #resetButton { background-image: linear-gradient(to right, #9ca3af, #6b7280); }
        #runButton:hover, #resetButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.15);
        }

        #canvas { width: 100%; height: auto; aspect-ratio: 16 / 9; border: 1px solid var(--border-color); background-color: #e0f2fe; border-radius: 8px; }
        #results { margin-top: 20px; padding: 15px; background-color: #f8fafc; border-radius: 8px; border: 1px solid var(--border-color); font-size: 1.1em; text-align: center; }
        
        .success { color: var(--success-green); font-weight: bold; }
        .failure { color: var(--failure-red); font-weight: bold; }
        
        #explanation-area { margin-top: 30px; }
        .equation { background: #f1f5f9; padding: 12px; border-radius: 5px; margin: 10px 0; font-size: 1.1em; overflow-x: auto; line-height: 1.8; }
        
        .calculation-grid { display: flex; flex-wrap: wrap; gap: 25px; margin-top: 20px; }
        .calc-column {
            flex: 1; min-width: 300px; padding: 20px; border: 1px solid var(--border-color);
            border-radius: 8px; background: #f8fafc;
        }
        .suvat-list { list-style: none; padding: 0; }
        .suvat-list li { margin-bottom: 5px; color: var(--secondary-text); }
        sub, sup { font-size: 0.8em; position: relative; line-height: 0; vertical-align: baseline; }
        sub { top: 0.5em; }
        sup { top: -0.5em; }
    </style>
</head>
<body>
    <header class="header">
        <img id="logo" src="lr-2.png" alt="LR Logo">
        <h1>2D Motion: The Net Problem</h1>
    </header>

    <div class="main-container">
        <div id="controls">
            <h2>Parameters</h2>
            <div class="slider-group"><label>Initial Height (Pillar): <span id="height-value" class="value-display"></span> m</label><input type="range" id="height" min="1" max="5" value="2.8" step="0.1"></div>
            <div class="slider-group"><label>Initial Speed: <span id="speed-value" class="value-display"></span> m/s</label><input type="range" id="speed" min="5" max="75" value="64" step="0.5"></div>
            <div class="slider-group"><label>Angle Below Horizontal: <span id="angle-value" class="value-display"></span>°</label><input type="range" id="angle" min="0" max="45" value="7" step="1"></div>
            <div class="slider-group"><label>Distance to Net: <span id="netDist-value" class="value-display"></span> m</label><input type="range" id="netDist" min="1" max="20" value="11.9" step="0.1"></div>
            <div class="slider-group"><label>Net Height: <span id="netHeight-value" class="value-display"></span> m</label><input type="range" id="netHeight" min="0.5" max="3" value="0.91" step="0.01"></div>
            <hr style="border: none; border-top: 1px solid var(--border-color); margin: 20px 0;">
            <div class="slider-group"><label>Simulation Speed: <span id="simSpeed-value" class="value-display"></span>x</label><input type="range" id="simSpeed" min="0.1" max="4" value="1" step="0.1"></div>
            <div class="button-group"><button id="runButton">Run Simulation</button><button id="resetButton">Reset</button></div>
        </div>
        <div id="simulation-area">
            <canvas id="canvas"></canvas>
            <div id="results">Set parameters and press "Run Simulation"</div>
        </div>
    </div>

    <div id="explanation-area">
        <h2>Solution by Two-Model Approach (SUVAT)</h2>
        <div id="solution-content"><p>Press "Run Simulation" to see the detailed calculations.</p></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const g = 9.81;
            const BALL_RADIUS_PX = 6;
            let animationFrameId;
            
            const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
            const resultsEl = document.getElementById('results'), solutionContentEl = document.getElementById('solution-content');
            const runButton = document.getElementById('runButton'), resetButton = document.getElementById('resetButton');

            const sliders = { height: document.getElementById('height'), speed: document.getElementById('speed'), angle: document.getElementById('angle'), netDist: document.getElementById('netDist'), netHeight: document.getElementById('netHeight'), simSpeed: document.getElementById('simSpeed') };
            const defaultValues = { height: 2.8, speed: 64, angle: 7, netDist: 11.9, netHeight: 0.91, simSpeed: 1 };
            const values = { height: document.getElementById('height-value'), speed: document.getElementById('speed-value'), angle: document.getElementById('angle-value'), netDist: document.getElementById('netDist-value'), netHeight: document.getElementById('netHeight-value'), simSpeed: document.getElementById('simSpeed-value') };

            function updateSliderDisplays() {
                for(const key in values) values[key].textContent = parseFloat(sliders[key].value).toFixed(key === 'simSpeed' || key === 'netHeight' ? 2 : (key === 'speed' || key === 'netDist' ? 1 : 0));
                values.height.textContent = parseFloat(sliders.height.value).toFixed(2);
            }
            
            function resetSimulation() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                for(const key in sliders) sliders[key].value = defaultValues[key];
                updateSliderDisplays();
                resultsEl.innerHTML = 'Set parameters and press "Run Simulation"';
                solutionContentEl.innerHTML = '<p>Press "Run Simulation" to see the detailed calculations.</p>';
                drawInitialSetup();
            }

            function runSimulation() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                const params = calculatePhysics();
                updateResultsAndExplanation(params);

                let lastTimestamp = 0, simTime = 0;
                function animate(timestamp) {
                    if (!lastTimestamp) lastTimestamp = timestamp;
                    const deltaTime = (timestamp - lastTimestamp) / 1000;
                    lastTimestamp = timestamp;
                    simTime += deltaTime * parseFloat(sliders.simSpeed.value);

                    if (simTime < params.t_ground) {
                        drawAnimatedFrame(simTime, params);
                        animationFrameId = requestAnimationFrame(animate);
                    } else {
                        drawAnimatedFrame(params.t_ground, params);
                        if(animationFrameId) cancelAnimationFrame(animationFrameId);
                    }
                }
                animationFrameId = requestAnimationFrame(animate);
            }
            
            function calculatePhysics() {
                const h = parseFloat(sliders.height.value), u = parseFloat(sliders.speed.value), angleDeg = parseFloat(sliders.angle.value), d_net = parseFloat(sliders.netDist.value), h_net = parseFloat(sliders.netHeight.value);
                const angleRad = -angleDeg * Math.PI / 180;
                const u_x = u * Math.cos(angleRad), u_y = u * Math.sin(angleRad);
                
                const t_g_temp = (-u_y - Math.sqrt(u_y*u_y - 4*(-0.5*g)*h)) / (2*(-0.5*g));
                const x_land_temp = u_x * t_g_temp;
                const { scale } = getCanvasConfig({h, d_net, x_land: x_land_temp});
                const ball_radius_m = BALL_RADIUS_PX / scale;
                
                const h_effective = h + ball_radius_m;
                const t_net = d_net / u_x;
                const y_center_at_net = h_effective + u_y * t_net - 0.5 * g * t_net * t_net;
                const clearance = (y_center_at_net - ball_radius_m) - h_net;
                
                const a_q = -0.5 * g, b_q = u_y, c_q = h_effective;
                const t_ground = (-b_q - Math.sqrt(b_q*b_q - 4*a_q*c_q)) / (2*a_q);
                const x_land = u_x * t_ground;
                
                const v_y_final = u_y - g * t_ground;
                const v_impact_mag = Math.sqrt(u_x*u_x + v_y_final*v_y_final);
                const v_impact_angle = Math.atan2(v_y_final, u_x) * 180 / Math.PI;

                return {clearance, y_center_at_net, x_land, d_net, v_impact_mag, v_impact_angle, h, u, angleDeg, h_net, u_x, u_y, t_net, h_effective, t_ground, v_y_final, ball_radius_m};
            }

            function getCanvasConfig(params) {
                const rect = canvas.parentElement.getBoundingClientRect();
                const canvasWidth = rect.width;
                const canvasHeight = rect.width * (9 / 16);
                
                const worldWidth = Math.max(params.d_net, params.x_land) * 1.2;
                const worldHeight = params.h * 1.25;
                const scale = Math.min(canvasWidth / worldWidth, canvasHeight / worldHeight);
                const padding = 50;
                const transform = (wx, wy) => ({ x: padding + wx * scale, y: canvasHeight - padding - wy * scale });

                return { canvasWidth, canvasHeight, scale, padding, transform };
            }
            
            function drawStaticScene(config, params) {
                const { canvasWidth, canvasHeight, transform } = config;
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                const { h, d_net, h_net } = params;
                
                ctx.beginPath(); ctx.moveTo(transform(0, 0).x, transform(0, 0).y); ctx.lineTo(canvasWidth, transform(0, 0).y); ctx.strokeStyle = '#664229'; ctx.lineWidth = 2; ctx.stroke();
                
                const netBottom = transform(d_net, 0), netTop = transform(d_net, h_net);
                ctx.beginPath(); ctx.moveTo(netBottom.x, netBottom.y); ctx.lineTo(netTop.x, netTop.y); ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 4; ctx.stroke();
                ctx.save();
                ctx.font = 'bold 14px Arial'; ctx.fillStyle = '#34495E'; ctx.textAlign = 'center';
                ctx.translate(netTop.x + 15, netTop.y + (netBottom.y - netTop.y) / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText(`h_net = ${h_net.toFixed(2)}m`, 0, 0);
                ctx.restore();

                const pillarWidth = 12;
                const pillarTop = transform(0, h);
                const groundY = transform(0, 0).y;
                ctx.fillStyle = '#5D6D7E';
                ctx.fillRect(pillarTop.x - pillarWidth / 2, pillarTop.y, pillarWidth, groundY - pillarTop.y);
                ctx.textAlign = 'right'; ctx.font = 'bold 14px Arial'; ctx.fillStyle = '#34495E';
                ctx.fillText(`${h.toFixed(1)}m`, pillarTop.x - 15, pillarTop.y + (groundY - pillarTop.y)/2);

                ctx.textAlign = 'center';
                ctx.fillText(`d_net = ${d_net.toFixed(1)}m`, pillarTop.x + (netBottom.x - pillarTop.x)/2, groundY + 25);
            }

            function drawInitialSetup() {
                const params = calculatePhysics();
                const config = getCanvasConfig(params);
                drawStaticScene(config, params);
                
                const { transform } = config;
                const { h_effective, angleDeg } = params;
                const angleRad = -angleDeg * Math.PI / 180;
                
                const startPos = transform(0, h_effective);

                ctx.beginPath(); ctx.arc(startPos.x, startPos.y, BALL_RADIUS_PX, 0, 2*Math.PI); ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-blue').trim(); ctx.fill();
                const angleLineLength = 40;
                ctx.beginPath(); ctx.moveTo(startPos.x, startPos.y); ctx.lineTo(startPos.x + angleLineLength * Math.cos(angleRad), startPos.y - angleLineLength * Math.sin(angleRad));
                ctx.strokeStyle = '#1e293b'; ctx.lineWidth = 2; ctx.stroke();
            }

            function drawAnimatedFrame(t, params) {
                const config = getCanvasConfig(params);
                drawStaticScene(config, params);

                const { transform, scale } = config;
                const { h_effective, u_x, u_y, t_ground, v_y_final, ball_radius_m } = params;
                
                const startPos = transform(0, h_effective);
                ctx.beginPath(); ctx.moveTo(startPos.x, startPos.y); ctx.strokeStyle = 'rgba(220, 38, 38, 0.5)'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                for (let i = 1; i <= 100; i++) {
                    const time_step = (i / 100) * t_ground;
                    const traj_x = u_x * time_step, traj_y = h_effective + u_y * time_step - 0.5 * g * time_step * time_step;
                    if (traj_y < ball_radius_m) break;
                    ctx.lineTo(transform(traj_x, traj_y).x, transform(traj_x, traj_y).y);
                }
                ctx.stroke();
                ctx.setLineDash([]);

                const ball_x_center = u_x * t;
                const ball_y_center = h_effective + u_y * t - 0.5 * g * t * t;
                const ball_pos = transform(ball_x_center, Math.max(ball_radius_m, ball_y_center));
                ctx.beginPath(); ctx.arc(ball_pos.x, ball_pos.y, BALL_RADIUS_PX, 0, 2 * Math.PI); ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--failure-red').trim(); ctx.fill();

                const vector_scale = scale * 0.15;

                if (t >= t_ground) {
                    const impactColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-purple').trim();
                    ctx.font = 'bold 14px Arial';
                    
                    const vx_end_x = ball_pos.x + u_x * vector_scale;
                    drawArrow(ctx, ball_pos.x, ball_pos.y, vx_end_x, ball_pos.y, impactColor, 3);
                    ctx.fillStyle = impactColor;
                    ctx.textAlign = 'right';
                    ctx.fillText(`vₓ = ${u_x.toFixed(2)} m/s`, ball_pos.x - 10, ball_pos.y - 15);

                    const vy_end_y = ball_pos.y - v_y_final * vector_scale;
                    drawArrow(ctx, ball_pos.x, ball_pos.y, ball_pos.x, vy_end_y, impactColor, 3);
                    ctx.fillStyle = impactColor;
                    ctx.textAlign = 'left';
                    const labelY = ball_pos.y + (vy_end_y - ball_pos.y) / 2 + 5;
                    ctx.fillText(`vᵧ = ${v_y_final.toFixed(2)} m/s`, ball_pos.x + 10, labelY);
                }
            }
            
            function drawArrow(ctx, fromx, fromy, tox, toy, color, width) {
                const headlen = 10;
                const dx = tox - fromx, dy = toy - fromy;
                const angle = Math.atan2(dy, dx);
                ctx.beginPath(); ctx.moveTo(fromx, fromy); ctx.lineTo(tox, toy);
                ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
                ctx.moveTo(tox, toy); ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
                ctx.strokeStyle = color; ctx.lineWidth = width; ctx.stroke();
            }

            function updateResultsAndExplanation(p) {
                resultsEl.innerHTML = (p.x_land < p.d_net) ? `<span class="failure">FAILS TO REACH NET</span><br>Lands at ${p.x_land.toFixed(2)}m.` :
                                      (p.clearance > 0) ? `<span class="success">CLEARS THE NET</span> by ${p.clearance.toFixed(2)}m.` :
                                                          `<span class="failure">HITS THE NET</span> (Missed by ${Math.abs(p.clearance).toFixed(2)}m).`;
                resultsEl.innerHTML += `<br>Final Impact Speed: ${p.v_impact_mag.toFixed(2)} m/s at ${p.v_impact_angle.toFixed(1)}°`;

                const successClass = p.clearance > 0 ? 'success' : 'failure';
                const conclusionText = p.x_land < p.d_net ? `The ball lands at ${p.x_land.toFixed(2)}m, short of the net.` :
                                       p.clearance > 0 ? `The ball's bottom edge is <span class="${successClass}">${p.clearance.toFixed(2)}m</span> above the net. It clears.` :
                                                         `The ball's bottom edge is <span class="${successClass}">${Math.abs(p.clearance).toFixed(2)}m</span> below the net. It hits.`;

                solutionContentEl.innerHTML = `
                    <p>The initial velocity (u = ${p.u.toFixed(1)} m/s at ${p.angleDeg}°) is resolved into components:</p>
                    <div class="equation" style="text-align:center;">
                        u<sub>x</sub> = u &middot; cos(θ) = <strong>${p.u_x.toFixed(2)} m/s</strong> &nbsp;&nbsp;|&nbsp;&nbsp; 
                        u<sub>y</sub> = u &middot; sin(θ) = <strong>${p.u_y.toFixed(2)} m/s</strong>
                    </div>

                    <div class="calculation-grid">
                        <div class="calc-column">
                            <h4>Horizontal Motion</h4>
                            <ul class="suvat-list">
                                <li><b>s</b> = ?</li>
                                <li><b>u</b> = ${p.u_x.toFixed(2)} m/s</li>
                                <li><b>v</b> = ${p.u_x.toFixed(2)} m/s</li>
                                <li><b>a</b> = 0 m/s²</li>
                                <li><b>t</b> = ?</li>
                            </ul>
                            <p><b>Find: Time to reach net (s = ${p.d_net}m)</b><br>Using s = ut</p>
                            <div class="equation">t<sub>net</sub> = s / u = ${p.d_net} / ${p.u_x.toFixed(2)} = <strong>${p.t_net.toFixed(2)} s</strong></div>
                            <p><b>Find: Final horizontal velocity (v<sub>x</sub>)</b><br>Remains constant.</p>
                            <div class="equation">v<sub>x</sub> = u<sub>x</sub> = <strong>${p.u_x.toFixed(2)} m/s</strong></div>
                        </div>
                        <div class="calc-column">
                            <h4>Vertical Motion</h4>
                            <ul class="suvat-list">
                                <li><b>s</b> = ?</li>
                                <li><b>u</b> = ${p.u_y.toFixed(2)} m/s</li>
                                <li><b>v</b> = ?</li>
                                <li><b>a</b> = -${g} m/s²</li>
                                <li><b>t</b> = ?</li>
                            </ul>
                            <p><b>Find: Height at net (at t = ${p.t_net.toFixed(2)}s)</b><br>Using s = ut + &frac12;at² from h<sub>eff</sub> = ${p.h_effective.toFixed(2)}m</p>
                            <div class="equation">y<sub>net</sub> = ${p.h_effective.toFixed(2)} + (${p.u_y.toFixed(2)})(${p.t_net.toFixed(2)}) + &frac12;(-${g})(${p.t_net.toFixed(2)})&sup2; = <strong>${p.y_center_at_net.toFixed(2)} m</strong></div>
                            <p><b>Find: Time to hit ground (s = -${p.h_effective.toFixed(2)}m)</b><br>Solving the quadratic from s = ut + &frac12;at² gives:</p>
                            <div class="equation">t<sub>ground</sub> = <strong>${p.t_ground.toFixed(2)} s</strong></div>
                            <p><b>Find: Final vertical velocity (v<sub>y</sub>)</b><br>Using v = u + at</p>
                            <div class="equation">v<sub>y</sub> = ${p.u_y.toFixed(2)} + (-${g})(${p.t_ground.toFixed(2)}) = <strong>${p.v_y_final.toFixed(2)} m/s</strong></div>
                        </div>
                    </div>
                    
                    <h3>Conclusion 1: Net Clearance</h3>
                    <p>The ball's center is at ${p.y_center_at_net.toFixed(2)}m vertically when it reaches the net. The ball's radius is ${p.ball_radius_m.toFixed(2)}m.</p>
                    <div class="equation">Clearance = (y<sub>net</sub> - r) - h<sub>net</sub> = (${p.y_center_at_net.toFixed(2)} - ${p.ball_radius_m.toFixed(2)}) - ${p.h_net} = <strong class="${successClass}">${p.clearance.toFixed(2)} m</strong></div>
                    <p><b>${conclusionText}</b></p>
                    
                    <h3>Conclusion 2: Final Impact</h3>
                    <p>The ball hits the ground with velocity components v<sub>x</sub> = ${p.u_x.toFixed(2)} m/s and v<sub>y</sub> = ${p.v_y_final.toFixed(2)} m/s.</p>
                    <p><b>Impact Speed (Magnitude):</b></p>
                    <div class="equation">|v| = &radic;(v<sub>x</sub>&sup2; + v<sub>y</sub>&sup2;) = &radic;(${p.u_x.toFixed(2)}&sup2; + ${p.v_y_final.toFixed(2)}&sup2;) = <strong>${p.v_impact_mag.toFixed(2)} m/s</strong></div>
                    <p><b>Impact Angle (below horizontal):</b></p>
                    <div class="equation">Angle = arctan(v<sub>y</sub> / v<sub>x</sub>) = arctan(${p.v_y_final.toFixed(2)} / ${p.u_x.toFixed(2)}) = <strong>${p.v_impact_angle.toFixed(1)}°</strong></div>
                `;
            }
            
            // Initialize
            for (const key in sliders) {
                sliders[key].addEventListener('input', () => {
                    updateSliderDisplays();
                    drawInitialSetup();
                });
            }
            runButton.addEventListener('click', runSimulation);
            resetButton.addEventListener('click', resetSimulation);
            
            resetSimulation();
        });
    </script>
</body>
</html>
